# Detailed Project Audit Checklist

## Chatbot App

### Backend
- [x] `chatbot_app/backend/.env`
  - **[SECURITY]** This file contains hardcoded secrets (API keys, database URL). This is a critical security vulnerability. All keys and credentials in this file should be considered compromised and must be rotated immediately.
  - **[SECURITY]** The `.env` file is not listed in any `.gitignore` file, meaning it is likely committed to version control. It must be added to `chatbot_app/backend/.gitignore` to prevent future commits.
  - **[IMPROVEMENT]** There is no corresponding `.env.example` or similar template file. This makes it difficult for new developers to set up the required environment variables. One should be created.
  - **[REDUNDANCY]** The file contains keys for Google Gemini and Mistral. A project-wide search should be conducted to confirm if these services are actually used. If not, the keys should be removed to reduce complexity and potential attack surface.
- [x] `chatbot_app/backend/main.py`
  - **[SECURITY/IMPROVEMENT]** The CORS middleware is configured with `allow_origins=["*"]`, which is insecure for production. This should be restricted to the actual frontend domain, ideally configured via an environment variable.
  - **[IMPROVEMENT]** The `uvicorn.run` command uses `reload=True`, which is suitable only for development. The production deployment script should disable this and use a proper process manager (e.g., Gunicorn).
  - **[IMPROVEMENT]** The startup and shutdown logic uses `print()` statements. For better monitoring and debugging in production, these should be replaced with a structured logging library (e.g., `loguru` or Python's built-in `logging`).
  - **[NOTE]** The overall structure is clean and follows FastAPI best practices, using a lifespan manager for startup/shutdown events and including a separate API router. This is good.
- [x] `chatbot_app/backend/requirements.txt`
  - **[CRITICAL]** Dependencies are not pinned to specific versions. This is a major risk, as it can lead to unpredictable builds and breaking changes from upstream libraries. A `pip freeze > requirements.txt` should be run in a clean, working virtual environment to lock down all direct and transitive dependencies.
  - **[REDUNDANCY]** The file includes both `asyncpg` and `psycopg2-binary`. `asyncpg` is the correct asynchronous driver for FastAPI with PostgreSQL. The synchronous `psycopg2-binary` is likely unnecessary and should be removed after confirming it's not used anywhere.
  - **[IMPROVEMENT]** There is no separation of development and production dependencies. It is best practice to maintain a `requirements-dev.txt` for tools like linters, formatters, and test runners, keeping the main `requirements.txt` lean for production.
  - **[NOTE]** The presence of `mistralai` confirms the intention to use the Mistral API, justifying the `MISTRAL_API_KEY` in the `.env` file.
- [x] `chatbot_app/backend/app/api.py`
  - **[CRITICAL/REFACTOR]** This file is a "God object" that violates the Single Responsibility Principle. It contains API routes, Pydantic models, complex business logic, and direct database queries. This makes it extremely difficult to maintain, test, and debug.
  - **[REFACTOR]** **Pydantic Models**: All `BaseModel` classes should be moved to a dedicated `app/schemas.py` or `app/models.py` file.
  - **[REFACTOR]** **Business Logic**: The core logic, especially the monolithic `stream_generator` function and the duplicated logic in the `/search` endpoint, should be extracted into a new service layer, for example `app/services/chat_service.py`. API endpoints should only be responsible for handling the HTTP request/response cycle.
  - **[REFACTOR]** **Database Queries**: All direct `db.query(...)` calls should be moved to a dedicated data access layer (e.g., `app/crud.py`). The complex SQL query in `get_chat_sessions` is a prime example. This will decouple the API from the database implementation.
  - **[IMPROVEMENT]** **Error Handling**: The generic `except Exception` blocks hide specific errors. The application should use more specific exception types and a centralized exception handler middleware in `main.py` to provide more meaningful HTTP responses.
  - **[IMPROVEMENT]** **Code Duplication**: The `/search` endpoint has significant code duplication between its streaming and non-streaming paths. This should be refactored to use a common set of underlying service functions.
  - **[SECURITY]** The `/transcribe` endpoint uses a user-provided filename to construct a file path (`os.path.join(temp_dir, file.filename)`), which is a potential path traversal vulnerability. The filename should be sanitized, or a secure, randomly generated name should be used instead.
  - **[NOTE]** The use of `instructor` for structured LLM outputs in the transcription post-processing endpoints is a good, modern practice that was implemented to fix a previous bug. This part is well-designed.
- [x] `chatbot_app/backend/app/database.py`
  - **[CRITICAL/INCONSISTENCY]** The database engine is created with the synchronous `create_engine`, but the application is asynchronous (FastAPI) and has `asyncpg` in its requirements. This is a major performance bottleneck and architectural mismatch. The code should be updated to use `create_async_engine` from `sqlalchemy.ext.asyncio` and the `DATABASE_URL` should be updated to the `postgresql+asyncpg://` scheme to leverage non-blocking IO.
  - **[IMPROVEMENT]** The `create_db_and_tables` function is suitable for development but not for production. A proper database migration tool like Alembic should be implemented to manage schema changes over time without requiring the database to be dropped and recreated.
  - **[IMPROVEMENT]** The code uses the legacy `declarative_base` from SQLAlchemy. While functional, it should be updated to the modern SQLAlchemy 2.0 style using `DeclarativeBase` and a `registry` for better maintainability and future compatibility.
  - **[NOTE]** The database models (`Transcription`, `ChatLog`) are well-defined and the loading of the `DATABASE_URL` from the environment is handled correctly.
- [x] `chatbot_app/backend/app/services/llm_handler.py`
  - **[IMPROVEMENT]** The model name (`gpt-4o`) is hardcoded in three separate functions. This should be defined as a single constant or, ideally, loaded from an environment variable (e.g., `OPENAI_MODEL_NAME`) to make model updates easier.
  - **[IMPROVEMENT]** Error handling is weak. The functions catch generic exceptions, `print()` to the console, and return `None` or a hardcoded error string. This hides the root cause from the caller. The functions should log errors properly and re-raise them as custom exceptions (e.g., `LLMAPIError`) to be handled gracefully by the API layer.
  - **[REFACTOR]** There is significant code duplication between `get_llm_response` and `get_llm_response_stream` for message and prompt preparation. This logic should be extracted into a private helper function to reduce redundancy.
  - **[IMPROVEMENT]** The use of `# type: ignore` for the `messages` list should be resolved. The code should use the specific `TypedDict` classes provided by the `openai` library for chat messages to improve type safety and code clarity.
  - **[NOTE]** The use of `instructor` to patch the OpenAI client and the `get_structured_response` function are well-implemented and represent good, modern practice for reliable structured data extraction.
- [x] `chatbot_app/backend/app/services/prompt_engine.py`
  - **[CRITICAL/REFACTOR]** The module has two conflicting designs for prompt creation. The `create_prompt` function contains a large, hardcoded RAG prompt. This is inflexible and inconsistent with `create_prompt_from_template`, which correctly loads prompts from external files. The hardcoded prompt should be moved to its own template file (e.g., `rag_search.txt`) and `create_prompt` should be refactored to use the template-loading mechanism.
  - **[IMPROVEMENT]** The calculation of `project_root` using a long chain of `os.path.join(..., '..')` is brittle and depends on the file's exact location. A more robust solution would be to define a `BASE_DIR` constant in a central config file or at the application's entry point and import it where needed.
  - **[IMPROVEMENT]** The `print()` statement used for debugging in `create_prompt` should be replaced with a proper logger call (e.g., `logger.debug(...)`) to align with standard logging practices.
  - **[NOTE]** The error handling in `create_prompt_from_template` is well-implemented, raising specific and informative exceptions.
- [x] `chatbot_app/backend/app/services/query_agent.py`
  - **[CRITICAL/REFACTOR]** The agent's core logic—a massive system prompt—is hardcoded directly inside the `_get_system_prompt` method. This is highly inflexible. This entire prompt should be moved to a dedicated template file (e.g., `query_deconstruction.txt`) and loaded using the `prompt_engine` service. This would decouple the agent's logic from its prompt and make the prompt much easier to version and manage.
  - **[REFACTOR]** The Pydantic models (`ExtractedFilters`, `DeconstructedQuery`) are defined locally. They should be moved to the central `app/schemas.py` file to be shared with the rest of the application, improving consistency and reusability.
  - **[IMPROVEMENT]** The service lacks explicit error handling. Any failure in the OpenAI API call will crash the method. It should include a `try...except` block to catch API errors and raise a specific custom exception (e.g., `QueryDeconstructionError`) to be handled by the API layer.
  - **[IMPROVEMENT]** The model name (`gpt-4o`) is hardcoded and should be sourced from a central configuration, just like in `llm_handler.py`.
  - **[RISK]** The prompt expects the LLM to calculate a Unix timestamp for relative dates (e.g., "30 days ago"). This is unreliable. The prompt should be redesigned to have the LLM extract a relative term (e.g., `{"unit": "days", "value": 30, "direction": "past"}`), and the agent code should be responsible for the actual date calculation.
  - **[NOTE]** The overall concept of using a dedicated agent with `instructor` to deconstruct queries into a structured format is a powerful and well-designed pattern.
- [x] `chatbot_app/backend/app/services/status_manager.py`
  - **[NOTE]** This is a simple, clean, and effective service. It correctly uses a dictionary to manage status messages and a module-level instance to act as a singleton. There are no significant issues or required changes in this file. It serves its purpose well.
  - **[IMPROVEMENT/FUTURE]** While not an issue now, if the application ever required internationalization (i18n), these hardcoded strings would need to be moved to a more robust localization framework.
- [x] `chatbot_app/backend/app/services/transcription.py`
  - **[CRITICAL/REFACTOR]** This entire module is written with synchronous code (`requests`, synchronous `OpenAI` client), which will block the event loop of the async FastAPI application, leading to severe performance degradation. Both `download_file` and `transcribe_audio` must be rewritten using asynchronous libraries (`httpx` for downloads, `AsyncOpenAI` for transcription).
  - **[IMPROVEMENT]** A new, separate `OpenAI` client is instantiated here. To maintain consistency and better manage resources, this service should import and reuse the shared, patched `AsyncOpenAI` client from `llm_handler.py`.
  - **[SECURITY]** The `download_file` function derives the local filename directly from the URL (`url.split("/")[-1]`). This is a security risk. The function should generate its own secure, random filename to save the downloaded content, preventing potential path traversal or file overwrite attacks.
  - **[IMPROVEMENT]** The transcription model (`whisper-1`) is hardcoded. It should be externalized into an environment variable (e.g., `OPENAI_WHISPER_MODEL`) for easier configuration.
  - **[IMPROVEMENT]** Error handling is minimal. The functions should include `try...except` blocks to catch network/API errors and raise specific custom exceptions that can be handled by the API layer.
- [x] `chatbot_app/backend/app/services/vector_db.py`
  - **[CRITICAL/REFACTOR]** The data ingestion logic is inside the `get_or_create_collection` function, which runs on application startup. This is a major design flaw. Populating a database, especially from a large CSV, should be an offline process handled by a separate script (e.g., in `data_pipelines/scripts`). The running API should only connect to an existing, populated database, not build it from scratch.
  - **[IMPROVEMENT]** The ChromaDB client is synchronous, which blocks the FastAPI event loop. While async support for the persistent client is limited, for a production system, these blocking calls should be wrapped with `FastAPI.run_in_executor` to avoid stalling the server.
  - **[IMPROVEMENT]** All paths (`EMBEDDINGS_CSV_PATH`, `CHROMA_DB_PATH`) and the `COLLECTION_NAME` are hardcoded. These should be moved to environment variables to allow for configuration flexibility between different environments (dev, test, prod).
  - **[RISK]** The use of `ast.literal_eval` to parse embeddings from a CSV is fragile. The data pipeline that creates the CSV should be updated to store embeddings in a more reliable format like JSON or a binary format (e.g., Parquet) to make ingestion more robust.
  - **[IMPROVEMENT]** Error handling relies on `print()` statements and overly broad `except Exception` blocks. This should be converted to use the standard `logging` module and raise more specific, custom exceptions.
  - **[NOTE]** The logic for searching and retrieving random documents is functional. The core issue is the startup-time data loading.

### Frontend

#### Root
- [x] `chatbot_app/frontend/.gitignore`
  - **[NOTE]** This is a standard, well-configured `.gitignore` file for a Next.js project. It correctly ignores `node_modules`, build artifacts (`.next`, `out`), and environment files (`.env*`). No issues found.
- [x] `chatbot_app/frontend/components.json`
  - **[NOTE]** This is the configuration file for the `shadcn/ui` library.
  - **[IMPROVEMENT]** The `tailwind.config` path is empty (`"config": ""`). While the CLI often finds `tailwind.config.js` by default, it's more robust to explicitly set this to `"tailwind.config.js"` to avoid potential issues if the project structure changes.
- [x] `chatbot_app/frontend/eslint.config.mjs`
  - **[NOTE]** This file configures ESLint using the modern "flat" config format. It correctly extends the recommended `next/core-web-vitals` and `next/typescript` configurations.
  - **[IMPROVEMENT]** The configuration is very basic. For a production environment, it would be beneficial to:
    - Integrate Prettier using `eslint-config-prettier` to prevent conflicts between ESLint rules and Prettier's formatting.
    - Add more specific plugins like `eslint-plugin-import` for consistent import sorting.
    - Consider adding custom rules, such as warning against the use of `console.log`.
- [x] `chatbot_app/frontend/next.config.ts`
  - **[CRITICAL]** The backend API URL is hardcoded in the `rewrites` configuration: `destination: "http://localhost:8000/api/:path*"`.
  - **[REASONING]** This will cause the application to fail in any deployed (staging, production) environment, as it will always try to connect to `localhost`.
  - **[RECOMMENDATION]** The destination URL must be externalized into an environment variable (e.g., `process.env.BACKEND_API_URL`). This allows the API endpoint to be configured independently for each environment without code changes.
- [x] `chatbot_app/frontend/package-lock.json`
  - **[NOTE]** This file is present and correctly locks the dependency tree, which is essential for reproducible builds. No issues with the file itself.
- [x] `chatbot_app/frontend/package.json`
  - **[CRITICAL RISK]** The project depends on bleeding-edge, non-production-ready versions of major libraries, including `next: "15.4.4"`, `react: "19.1.0"`, and `tailwindcss: "^4"`.
  - **[REASONING]** Using pre-release versions (Canary, RC, Alpha, Beta) for a project is highly risky. It exposes the project to frequent breaking changes, instability, bugs, and a lack of community support and documentation.
  - **[RECOMMENDATION]** Downgrade all major dependencies to the latest stable, Long-Term Support (LTS) versions to ensure stability and reliability. For example, use the latest stable version of Next.js 14.
  - **[IMPROVEMENT]** Dependency versions are not pinned (they use `^`). While `package-lock.json` helps, pinning versions provides an extra layer of safety against unintended updates.
- [x] `chatbot_app/frontend/postcss.config.mjs`
  - **[NOTE]** This file is correctly configured for Tailwind CSS v4. It uses the modern `@tailwindcss/postcss` plugin, which is the current best practice. No issues found.
- [x] `chatbot_app/frontend/README.md`
  - **[CRITICAL]** This is the default, unmodified README from `create-next-app`. It contains no information specific to this project.
  - **[REASONING]** A project without a proper README is extremely difficult for new developers to onboard. It lacks setup instructions, environment variable definitions, and an overview of the project's purpose and architecture.
  - **[RECOMMENDATION]** The README should be completely rewritten to include:
    - A detailed project description.
    - Setup instructions for both the frontend and backend.
    - A list and explanation of all required environment variables (for both frontend and backend).
    - Instructions on how to run the full application stack locally.
    - An overview of the architecture and key technologies used.
- [x] `chatbot_app/frontend/tailwind.config.js`
  - **[NOTE]** This is a standard Tailwind configuration for a `shadcn/ui` project, defining custom colors, radii, and animations using CSS variables.
  - **[INCONSISTENCY]** The `package.json` specifies Tailwind CSS v4, but this configuration file uses the v3 format. While it may work due to backward compatibility, it's not idiomatic for v4 and may not leverage new features correctly.
  - **[IMPROVEMENT]** The project is written in TypeScript, but this configuration file is JavaScript (`.js`). It should be converted to a TypeScript file (`tailwind.config.ts`) to enable type-checking and improve consistency across the codebase.
- [x] `chatbot_app/frontend/tsconfig.json`
  - **[NOTE]** This is a well-configured TypeScript configuration file. It correctly enables `"strict": true` mode and uses the modern `"moduleResolution": "bundler"`, which are best practices. The path alias for `@/*` is also correctly configured. No issues found.

#### Public Directory
- [x] `chatbot_app/frontend/public/file.svg`
  - **[IMPROVEMENT]** The SVG has a hardcoded `fill="#666"`. For better theming (especially with dark mode), this should be removed. The color should be applied via CSS using Tailwind's `fill-current` utility in the component where the icon is used, allowing it to inherit the text color.
  - **[NOTE]** The SVG is not minified, but for a small icon, the performance impact is negligible.
- [x] `chatbot_app/frontend/public/globe.svg`
  - **[IMPROVEMENT]** Similar to `file.svg`, this icon has a hardcoded `fill="#666"`. This should be removed to allow for dynamic coloring via CSS (`fill-current`) for better theming support.
  - **[NOTE]** The SVG is not minified.
- [x] `chatbot_app/frontend/public/mock-data.csv`
  - **[IMPROVEMENT/RISK]** This is a large (4000+ lines) mock data file stored in the `public` directory.
  - **[REASONING]** Committing large data files to Git bloats the repository. More importantly, placing it in the `public` folder means it will be included in the production deployment bundle, unnecessarily increasing its size. This file is clearly for development/testing purposes only.
  - **[RECOMMENDATION]** This file should be removed from the repository and added to `.gitignore`. For local development, it can be provided to developers separately or loaded conditionally only when `NODE_ENV` is set to `development`. Production data should always be fetched from the API.
- [x] `chatbot_app/frontend/public/next.svg`
  - **[IMPROVEMENT]** The SVG has a hardcoded `fill="#000"`.
  - **[REASONING]** This makes the icon's color static and unresponsive to CSS theme changes (e.g., light/dark mode).
  - **[RECOMMENDATION]** Remove the `fill` attribute from the SVG and control the color via CSS using the `currentColor` value. This will allow the icon to inherit its color from the parent text color, making it easily themeable.
- [x] `chatbot_app/frontend/public/vercel.svg`
  - **[IMPROVEMENT]** The SVG has a hardcoded `fill="#fff"`.
  - **[REASONING]** This makes the icon's color static and unresponsive to CSS theme changes (e.g., light/dark mode).
  - **[RECOMMENDATION]** Remove the `fill` attribute from the SVG and control the color via CSS using the `currentColor` value. This will allow the icon to inherit its color from the parent text color, making it easily themeable.
- [x] `chatbot_app/frontend/public/window.svg`
  - **[IMPROVEMENT]** The SVG has a hardcoded `fill="#666"`.
  - **[REASONING]** This makes the icon's color static and unresponsive to CSS theme changes (e.g., light/dark mode).
  - **[RECOMMENDATION]** Remove the `fill` attribute from the SVG and control the color via CSS using the `currentColor` value. This will allow the icon to inherit its color from the parent text color, making it easily themeable.

#### Source Directory (`src`)
- [x] `chatbot_app/frontend/src/app/favicon.ico`
  - **[NOTE]** This is the default Next.js favicon. It is correctly placed in the `/app` directory, which Next.js uses by convention. No explicit link is needed in `layout.tsx`, but it's better practice to define icons in the `metadata` object for more control.
- [x] `chatbot_app/frontend/src/app/globals.css`
  - **[INCONSISTENCY]** The CSS file uses modern Tailwind CSS v4 syntax (`@import "tailwindcss"`, `@theme`), but the `tailwind.config.js` file uses the older v3 format. This indicates a mixed and potentially unstable setup. The config file should be updated to the v4 format.
  - **[INCONSISTENCY]** The theme defines variables for the Geist font (`--font-geist-sans`, `--font-geist-mono`), but the `layout.tsx` file loads the "Inter" font. The application is not using the fonts defined in its own theme. The font loading in `layout.tsx` should be changed to use Geist to match the CSS.
  - **[REDUNDANCY]** The file includes both `@import "tailwindcss";` at the top and the individual `@tailwind base;`, `@tailwind components;`, `@tailwind utilities;` directives at the bottom. The single `@import` is the correct v4 syntax and includes the others. The individual directives are redundant and should be removed.
  - **[NOTE]** The use of the `oklch()` color model and a comprehensive set of CSS variables for theming are both excellent, modern CSS practices.
- [x] `chatbot_app/frontend/src/app/layout.tsx`
  - **[IMPROVEMENT]** The page `title` and `description` in the `metadata` object are the default placeholders from `create-next-app`. These should be updated to be specific to this application.
  - **[IMPROVEMENT/BUG]** The Inter font is loaded twice: once using `next/font/google` and again with a manual `<link>` tag in the `<head>`. The manual link is redundant and should be removed to rely on the optimized `next/font` implementation.
  - **[RISK]** The `<html>` tag has `suppressHydrationWarning={true}`. This is often used to silence warnings from libraries like `shadcn/ui`'s `ThemeProvider` when using dark mode. While it fixes the console error, it can mask real hydration mismatch bugs. This should be noted as a potential issue that might need a more robust solution than just suppressing the warning.
- [x] `chatbot_app/frontend/src/app/page.tsx`
  - **[REFACTOR/ARCHITECTURAL]** This component is the root of significant "prop drilling." State (`messages`, `sessionId`) and state setters (`setMessages`, `setSessionId`) are held in this top-level component and passed down through `Sidebar` and `ChatInterface`. This makes state management complex and hard to trace.
  - **[RECOMMENDATION]** A centralized state management solution (like Zustand, Jotai, or even React Context) should be implemented. This would allow components at any level to access and update shared state without having to pass props through intermediate components.
  - **[IMPROVEMENT]** The `refreshKey` state is used as a mechanism to force the `Sidebar` to re-fetch data. This is an implicit and potentially confusing pattern. A better approach would be to use a dedicated data-fetching library (like React Query or SWR) that handles caching, re-validation, and refreshes more explicitly.
  - **[IMPROVEMENT]** The main content area has a hardcoded `ml-64` to avoid overlapping with the sidebar. This is not robust. A better CSS layout strategy (e.g., using CSS Grid or Flexbox for the main layout) would allow the content area to adapt dynamically to the sidebar's width.
- [x] `chatbot_app/frontend/src/app/api/calls/route.ts`
  - **[CRITICAL/ARCHITECTURAL]** This API route exists solely to read data from the local `mock-data.csv` file. It completely bypasses the actual Python backend. This is a major flaw, as the frontend is fundamentally disconnected from the real application logic and database.
  - **[REDUNDANCY]** This entire API route is unnecessary. The frontend should be making API calls directly to the backend service (which is what the `rewrites` in `next.config.ts` is for). This file and the `data.ts` lib it depends on should be deleted.
- [x] `chatbot_app/frontend/src/app/dashboard/page.tsx`
  - **[CRITICAL/ARCHITECTURAL]** The entire dashboard is powered by the mock `/api/calls` endpoint that reads from a CSV. This means the dashboard is completely non-functional and does not reflect any real application data. It is a placeholder.
  - **[INEFFICIENCY]** All data aggregation (calculating totals, averages, data for charts) is performed on the client side. For any significant amount of data, this would be extremely slow and inefficient. The backend should be responsible for performing these aggregations and providing dedicated endpoints for the dashboard's data needs.
  - **[IMPROVEMENT]** The `BarChart` and `LineChart` components are rendered without being passed any data props. This suggests the chart components themselves contain hardcoded data, making them non-reusable and static. They should be refactored to accept data as props.
  - **[IMPROVEMENT]** There is no loading state indicator while the initial data is being fetched. The user will see an empty or incomplete dashboard until the data arrives.
  - **[IMPROVEMENT]** The `fetch` call has no `.catch()` block or other mechanism for handling network or API errors.
  - **[NOTE]** The page title is hardcoded as a placeholder: "📊 Placeholder Call Analytics Dashboard".
- [x] `chatbot_app/frontend/src/app/history/page.tsx`
  - **[NOTE]** This component correctly fetches data from the backend API (`/api/transcriptions`), unlike the dashboard. This is a much better pattern.
  - **[IMPROVEMENT]** The delete functionality is not "optimistic." The UI waits for the delete request and the subsequent refresh to complete before removing the item from the list. For a better user experience, the item should be removed from the UI immediately, and then an error shown if the backend call fails.
  - **[IMPROVEMENT]** The error handling is basic. It displays an error message but provides no way for the user to retry the failed network request.
  - **[IMPROVEMENT]** The `AlertDialog` for confirming deletion is defined directly within the page. It would be more reusable if it were extracted into its own component.
  - **[IMPROVEMENT]** The `catch (err: any)` block should be more type-safe by checking `if (err instanceof Error)` before accessing `err.message`.
- [x] `chatbot_app/frontend/src/app/history/[id]/page.tsx`
  - **[NOTE]** This is a well-structured component. It correctly fetches data for a dynamic ID, handles loading and error states, and uses conditional rendering for the different transcription tabs.
  - **[IMPROVEMENT]** The `catch (err: any)` block should be made more type-safe by checking `if (err instanceof Error)` before accessing `err.message`.
  - **[NOTE]** The fallback logic for `finalTranscript` is a good example of defensive coding.
- [x] `chatbot_app/frontend/src/app/transcribe/page.tsx`
  - **[CRITICAL/REFACTOR]** This is a "God Component." It contains an excessive amount of state (9+ `useState` hooks) and all the logic for the entire multi-step transcription process (upload, transcribe, post-process, correct). This makes it incredibly difficult to maintain and debug.
  - **[RECOMMENDATION]** This component must be broken down.
    - The data-fetching logic should be extracted into custom hooks (e.g., `useTranscription`, `usePostProcess`).
    - The UI should be split into smaller, more focused components (e.g., `FileUpload`, `TranscriptionResult`).
    - The complex state logic should be managed by a reducer (`useReducer`) or a state machine library (like XState) to make the different states (loading, processing, correcting, error) explicit and manageable.
  - **[DEAD CODE]** The entire "Correct Company Name" feature is commented out in the JSX. This should either be properly implemented or removed entirely.
  - **[INCONSISTENCY]** Error handling is inconsistent across the different API calls. A unified approach to handling and displaying API errors is needed.
- [x] `chatbot_app/frontend/src/components/chart.tsx`
  - **[IMPROVEMENT]** The component has hardcoded colors for its styles (e.g., `stroke="#9ca3af"`, `fill="#6366f1"`). These will not adapt to the application's theme (light/dark mode).
  - **[RECOMMENDATION]** The hardcoded colors should be replaced with the application's CSS variables (e.g., `stroke="var(--color-muted-foreground)"`) to make the charts theme-aware.
  - **[IMPROVEMENT]** The `data` prop is typed as `any[]`. This is not type-safe. Using a generic type (`<T>`) would make the component more robust and provide better type-checking.
  - **[NOTE]** The component is well-designed for reusability by accepting `data`, `xAxisKey`, and `yAxisKey` as props.
- [x] `chatbot_app/frontend/src/components/chat-interface.tsx`
  - **[CRITICAL/ARCHITECTURAL]** This is a massive "God Component" that is responsible for the entire chat UI, state management, and data fetching logic. It is over 300 lines long and is extremely difficult to maintain.
  - **[REFACTOR]** The component must be broken down:
    - The complex data-fetching and SSE parsing logic in `handleSendMessage` should be extracted into a custom hook (e.g., `useChatStream`).
    - The UI for rendering messages, displaying sources, and the input form should be extracted into smaller, dedicated components.
    - The complex state machine (managing loading, streaming, status updates, etc.) should be managed with a reducer (`useReducer`) or a state machine library to make it more robust and predictable.
  - **[INEFFICIENCY]** The component updates the React state (`setMessages`) inside a `while` loop for every chunk of the SSE stream. This can cause a high number of re-renders and is inefficient. State updates should be batched where possible.
  - **[RISK]** The manual SSE parsing logic is fragile and could break if the data format changes slightly. This should be handled by a more robust, dedicated utility.
- [x] `chatbot_app/frontend/src/components/ConversationView.tsx`
  - **[CRITICAL/ARCHITECTURAL]** The component's primary job is to parse a single, large string into a structured conversation. This is a major architectural flaw. The backend API should be responsible for this parsing and should return a structured JSON array of conversation turns, not a string that the frontend has to guess how to parse.
  - **[BUG/RISK]** The parsing logic, which splits on literal `\\n` and uses a regex, is extremely fragile. Any small change in the backend's output format will break this component completely.
  - **[IMPROVEMENT]** The styling for different speakers is hardcoded in `switch` statements. This is inflexible. If new speaker roles are added, the frontend code will need to be changed. This could be made more data-driven.
- [x] `chatbot_app/frontend/src/components/data-table.tsx`
  - **[IMPROVEMENT]** The `data` prop is typed as `any[]`. This is not type-safe and should be converted to use a generic type (`<T>`).
  - **[IMPROVEMENT]** The component is extremely basic. It lacks essential features for a data table, such as sorting, filtering, and pagination. For any real application, this component would need to be significantly enhanced or replaced with a more robust library like TanStack Table.
  - **[RISK]** The `key` prop for each row is the array `index`. This is not a stable identifier and can lead to bugs if the data is sorted or filtered. A unique ID from the data itself should be used instead.
- [x] `chatbot_app/frontend/src/components/prompt-card.tsx`
  - **[IMPROVEMENT]** The card `title` has a hardcoded color (`text-blue-900`) that will not adapt to the application's theme. It should use a theme-aware color like `text-primary`.
  - **[NOTE]** This is a well-designed, reusable presentational component. It correctly takes all its data and callbacks as props.
- [x] `chatbot_app/frontend/src/components/sidebar.tsx`
  - **[ARCHITECTURAL]** This component is a prime example of the problems caused by "prop drilling." It receives state setters (`setMessages`, `setSessionId`) from its parent to control other components, creating a confusing and tightly coupled architecture. This is a strong argument for a centralized state management solution.
  - **[INEFFICIENCY]** The search functionality is client-side only. This will not scale well if the user has a large number of chat sessions. The backend should provide an endpoint for searching chats.
  - **[IMPROVEMENT]** The component relies on the `refreshKey` prop to know when to re-fetch data. This is an implicit and fragile pattern. A proper data-fetching library (like React Query or SWR) would handle this more robustly.
  - **[IMPROVEMENT]** Error handling is limited to `console.error`. If the API calls fail, the user is not notified, which is a poor user experience.
  - **[IMPROVEMENT]** The component has a fixed width and is not responsive. On mobile devices, a collapsible drawer would be a much better UI pattern.
- [x] `chatbot_app/frontend/src/components/status-box.tsx`
  - **[NOTE]** This is a simple, clean, and well-written presentational component. No issues found.
- [x] `chatbot_app/frontend/src/components/theme-provider.tsx`
  - **[IMPROVEMENT]** The component's props are typed as `any`, which is not type-safe. It should import and use the `ThemeProviderProps` type from the `next-themes` library for better type-checking.
  - **[NOTE]** This is the standard and correct implementation for using the `next-themes` library in a Next.js App Router project.
- [x] `chatbot_app/frontend/src/components/theme-toggle.tsx`
  - **[NOTE]** This is a standard, well-written component that correctly implements the theme-switching functionality using `next-themes` and `shadcn/ui`. No issues found.
- [x] `chatbot_app/frontend/src/components/transcript-dialog.tsx`
  - **[IMPROVEMENT]** The dialog displays the `full_journey` as raw, unformatted text inside a `<pre>` tag. For a better user experience, it should use the `ConversationView` component to render the journey as a formatted, chat-style conversation.
  - **[NOTE]** This is a well-written, controlled component. It correctly receives its state and callbacks as props. No bugs found.
- [x] `chatbot_app/frontend/src/components/welcome-screen.tsx`
  - **[IMPROVEMENT]** The component contains a significant amount of hardcoded content, including the user's name ("Lorenz"), the campaign name ("Medlytics"), and the list of suggested prompts. In a real application, this data should be dynamic and fetched from an API or user session.
  - **[NOTE]** The component is otherwise well-structured, correctly using the `PromptCard` component and callbacks.
- [x] `chatbot_app/frontend/src/components/charts/BarChart.tsx`
  - **[CRITICAL/REDUNDANCY]** This component is completely redundant. The project has a generic, reusable `Chart` component in `/components/chart.tsx` that can render a bar chart.
  - **[BUG]** The component has hardcoded placeholder data, which is why the dashboard displays a static, meaningless chart.
  - **[RECOMMENDATION]** This file should be deleted. The dashboard should be refactored to use the generic `Chart` component and pass the real (or at least, dynamically processed) data to it.
  - **[IMPROVEMENT]** The bar `fill` color is hardcoded and not theme-aware.
- [x] `chatbot_app/frontend/src/components/charts/LineChart.tsx`
  - **[CRITICAL/REDUNDANCY]** This component is redundant. A generic, reusable chart component should be used instead.
  - **[BUG]** The component has hardcoded placeholder data, which is why the dashboard displays a static, meaningless chart.
  - **[RECOMMENDATION]** This file should be deleted. The dashboard should be refactored to use a generic `Chart` component (or a new generic `LineChart` component) and pass the real data to it.
  - **[IMPROVEMENT]** The line `stroke` color is hardcoded and not theme-aware.
- [x] `chatbot_app/frontend/src/components/ui/alert-dialog.tsx`
  - **[NOTE]** This is the standard, unmodified `AlertDialog` component from the `shadcn/ui` library. It is well-written and accessible. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/avatar.tsx`
  - **[NOTE]** This is the standard, unmodified `Avatar` component from the `shadcn/ui` library. It is well-written and accessible. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/button.tsx`
  - **[NOTE]** This is the standard, unmodified `Button` component from the `shadcn/ui` library. It is well-written, flexible, and uses `class-variance-authority` correctly. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/card.tsx`
  - **[NOTE]** This is the standard, unmodified `Card` component from the `shadcn/ui` library. It is well-written and composable. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/context-menu.tsx`
  - **[NOTE]** This is the standard, unmodified `ContextMenu` component from the `shadcn/ui` library. It is well-written and accessible. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/dialog.tsx`
  - **[NOTE]** This is the standard `Dialog` component from the `shadcn/ui` library, with a minor, useful customization to conditionally show the close button. It is well-written and accessible. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/dropdown-menu.tsx`
  - **[NOTE]** This is the standard, unmodified `DropdownMenu` component from the `shadcn/ui` library. It is well-written and accessible. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/input.tsx`
  - **[NOTE]** This is the standard, unmodified `Input` component from the `shadcn/ui` library. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/KPICard.tsx`
  - **[IMPROVEMENT]** The component uses hardcoded colors (`text-gray-500`, `text-green-500`) that are not theme-aware. These should be replaced with theme variables (e.g., `text-muted-foreground`).
  - **[IMPROVEMENT]** The `change` prop is always styled as green. The component would be more reusable if it could conditionally style the change indicator based on whether the value is positive or negative.
  - **[NOTE]** This is a simple and effective presentational component.
- [x] `chatbot_app/frontend/src/components/ui/scroll-area.tsx`
  - **[NOTE]** This is the standard, unmodified `ScrollArea` component from the `shadcn/ui` library. It is well-written and accessible. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/select.tsx`
  - **[NOTE]** This is the standard, unmodified `Select` component from the `shadcn/ui` library. It is well-written and accessible. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/table.tsx`
  - **[NOTE]** This is the standard, unmodified `Table` component from the `shadcn/ui` library. It is well-written and accessible. No issues found.
- [x] `chatbot_app/frontend/src/components/ui/tabs.tsx`
  - **[NOTE]** This is the standard, unmodified `Tabs` component from the `shadcn/ui` library. It is well-written and accessible. No issues found.
- [x] `chatbot_app/frontend/src/lib/data.ts`
  - **[CRITICAL/ARCHITECTURAL]** This file reads `mock-data.csv` from the filesystem. This is the root cause of the frontend using mock data instead of real data from the backend. This approach is only suitable for a static site prototype, not a full-stack application.
  - **[BUG/RISK]** The CSV parsing logic (`row.split(',')`) is extremely fragile and will fail if any data field contains a comma. It also doesn't account for other common CSV complexities like quoted strings.
  - **[RECOMMENDATION]** This file should be deleted. All data fetching logic should be moved into the components that need it (or a shared hook) and should make `fetch` requests to the backend API endpoints.
- [x] `chatbot_app/frontend/src/lib/utils.ts`
  - **[NOTE]** This file contains the standard `cn` utility function from `shadcn/ui` for merging Tailwind CSS classes. It is a best-practice utility. No issues found.

## Other Project Files

### Root Directory
- [x] `.gitignore`
  - **[IMPROVEMENT]** The file is missing an entry for the `chroma_db/` directory. Database files should never be committed to version control.
  - **[IMPROVEMENT]** The file is missing an entry for the `mock-data.csv` file, which is a large development asset that should not be in version control.
  - **[REDUNDANCY]** The entries for `llm_context/` and `llm_response/` are duplicated.
  - **[NOTE]** The file correctly ignores most standard Python, Node.js, and environment files.
- [x] `audit_checklist.md`
  - **[NOTE]** This file does not exist in the repository. It was likely the predecessor to this `detailed_audit_checklist.md`. The reference to it in this checklist should be removed.
- [x] `batching_idea.md`
  - **[NOTE]** This is a well-written architectural document describing a "chunk-and-aggregate" strategy for processing large volumes of text with an LLM. This provides crucial context for the intended design of the `data_pipelines`.
  - **[IMPROVEMENT]** The Python code examples in the document use a deprecated version of the `openai` library (`v0.x`). If this document is to be kept as active documentation, the code samples should be updated to reflect the current `v1.x+` syntax.
- [x] `customer_journey_pipeline.md`
  - **[NOTE]** This is a clear and well-written architectural document that outlines the intended data processing pipeline for customer journey analysis. It provides excellent context for the purpose of the scripts and prompts in the `data_pipelines/` directory. No issues found.

### Data Pipelines
- [x] `data_pipelines/` (Directory structure)
  - **[CRITICAL]** The `data/` subdirectory contains a large number of `.mp3` audio files and `.csv` data files. Committing large binary and data files directly to a Git repository is a major anti-pattern that bloats the repository and makes it slow and difficult to manage.
  - **[RECOMMENDATION]** All data files should be removed from the Git repository (using a tool like `git-filter-repo` to clean the history) and stored in a dedicated object storage service (like S3). The `data/` directory should be added to the root `.gitignore` file.
  - **[NOTE]** The overall directory structure (`data/`, `prompts/`, `scripts/`) is logical and well-organized.
- [x] `data_pipelines/prompts/` (Directory and contents)
  - **[NOTE]** This directory contains a suite of well-written and highly-detailed prompts that define the core logic of the data analysis pipeline. The use of clear instructions, examples, and strict JSON output formats is an excellent practice.
  - **[NOTE]** The prompts align with the architectures described in `batching_idea.md` and `customer_journey_pipeline.md`, demonstrating a cohesive design.
  - **[RISK]** A significant amount of business logic (e.g., the "Gatekeeper Strategy") is hardcoded into these prompts. Any change in business strategy will require careful editing of these text files to ensure the AI's analysis remains aligned with the new strategy.
- [x] `data_pipelines/scripts/` (Directory and contents)
  - **[CRITICAL]** There is no `requirements.txt` file for this data pipeline. This is a critical omission that makes it impossible to create a reproducible environment for running these scripts.
  - **[REDUNDANCY/RISK]** There are multiple, conflicting versions of key scripts (e.g., `1_select_customers.py` vs. `1_select_recordings.py`, and `4_embed_transcripts.py` vs. `4b_embed_journeys.py`). This is confusing and could lead to running the wrong pipeline. The unused, legacy scripts should be deleted.
  - **[IMPROVEMENT]** The scripts are full of hardcoded file paths. These should be refactored into a central configuration file or passed as command-line arguments to make the pipeline more flexible.
  - **[IMPROVEMENT]** The scripts are designed to be run manually in a specific sequence. A single orchestrator script (e.g., `run_pipeline.py`) should be created to run the entire pipeline in the correct order.
  - **[NOTE]** The sequential naming convention of the scripts is excellent and makes the intended workflow easy to understand.